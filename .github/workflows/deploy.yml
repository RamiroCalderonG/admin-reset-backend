Guía de CI/CD con GitHub Actions y Runner Autohospedado en Proxmox
Este documento te guiará a través de los pasos para configurar un flujo de Integración Continua/Despliegue Continuo (CI/CD) utilizando un runner autohospedado de GitHub Actions en tu Máquina Virtual (VM) de Proxmox. Esto es ideal para entornos detrás de CGNAT, ya que tu VM iniciará la conexión con GitHub, evitando problemas de acceso entrante.

Paso 1: Preparar tu Repositorio Git
Crea un repositorio Git: Si aún no lo tienes, inicializa un repositorio Git en tu carpeta admin-reset-backend y súbelo a GitHub.

cd /Users/ramirocalderon/Dev/admin-reset-backend
git init
git add .
git commit -m "Initial backend commit"
git branch -M main
git remote add origin https://github.com/tu_usuario/tu_repo_backend.git # Cambia esto
git push -u origin main

Asegúrate de que .env no esté en Git: El archivo .env contiene información sensible (credenciales de Google, de DB). Nunca debe subirse a tu repositorio público.

Crea o edita el archivo .gitignore en la raíz de tu proyecto admin-reset-backend.

Añade la siguiente línea:

.env
service-account-key.json
node_modules/

Si ya lo subiste por error, deberás eliminarlo del historial de Git. Busca cómo hacer git rm --cached .env y luego un git commit --amend --no-edit y git push --force.

Paso 1.1: ELIMINAR ARCHIVOS SENSIBLES DEL HISTORIAL DE GIT (¡CRÍTICO!)
Si por error subiste service-account-key.json (o .env) a tu repositorio Git, necesitas eliminarlo completamente del historial. Esto es irreversible y afectará a cualquier persona que haya clonado el repositorio.

¡ADVERTENCIA IMPORTANTE!

Haz una copia de seguridad de tu repositorio local actual antes de proceder. Simplemente copia la carpeta admin-reset-backend a otro lugar.

Este proceso reescribe el historial de Git. Si otras personas están colaborando, todos deberán volver a clonar el repositorio después de este cambio.

Método Recomendado: git filter-repo (Requiere Python)

git filter-repo es la herramienta más moderna, rápida y segura para reescribir el historial de Git.

Instala git filter-repo:

pip install git-filter-repo
# O si usas Homebrew en macOS:
# brew install git-filter-repo

Navega a la raíz de tu repositorio local:

cd /Users/ramirocalderon/Dev/admin-reset-backend

Ejecuta el comando para eliminar el archivo:

git filter-repo --path service-account-key.json --invert-paths --force

--path service-account-key.json: Especifica el archivo a eliminar.

--invert-paths: Significa "mantén todo EXCEPTO este archivo".

--force: Necesario porque estás reescribiendo el historial.

Si también subiste .env, puedes ejecutarlo de nuevo para ese archivo o combinarlos (aunque es más seguro hacer uno por uno y verificar):

git filter-repo --path .env --invert-paths --force

Forzar el push al repositorio remoto:
Después de reescribir el historial local, necesitas forzar la actualización del repositorio remoto.

git push origin --force --all
git push origin --force --tags

Esto sobrescribirá el historial en GitHub.

Método Alternativo: git filter-branch (Más lento y complejo, pero integrado en Git)

Si no puedes instalar git filter-repo, puedes usar git filter-branch.

Haz una copia de seguridad de tu repositorio local.

Navega a la raíz de tu repositorio local.

Ejecuta el comando para eliminar el archivo:

git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch service-account-key.json' --prune-empty --tag-name-filter cat -- --all

Este comando reescribirá cada commit en tu historial para eliminar el archivo del índice.
Si también subiste .env, ejecuta el comando de nuevo para .env.

Elimina las referencias antiguas (opcional pero recomendado):

git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
git reflog expire --expire=now --all
git gc --prune=now

Esto limpia las referencias antiguas y los objetos no alcanzables.

Forzar el push al repositorio remoto:

git push origin --force --all
git push origin --force --tags

Después de cualquiera de los métodos:

Verifica en GitHub: Abre tu repositorio en GitHub y asegúrate de que el archivo service-account-key.json (y .env) ya no aparezca en ninguna parte del historial de archivos.

Asegúrate de que .env y service-account-key.json estén en tu .gitignore para evitar que se suban de nuevo en el futuro.

Paso 2: Preparar tu VM de Proxmox para el Runner Autohospedado
Esta VM será el "runner" que ejecutará las acciones de GitHub. Asumimos que ya tienes una VM de Ubuntu Server en Proxmox con Node.js, npm y PM2 instalados (como en los pasos anteriores).

Conéctate a tu VM de Node.js en Proxmox vía SSH.

Crea un usuario dedicado para el runner (recomendado):
Por seguridad, es buena práctica ejecutar el runner con un usuario con privilegios limitados.

sudo adduser github-runner
sudo usermod -aG sudo github-runner # Otorga permisos de sudo si es necesario para ciertas operaciones (ej. npm install -g)

Luego, cambia a este usuario:

su - github-runner

Todos los comandos subsiguientes en la VM se ejecutarán como este usuario.

Instala las dependencias necesarias para el runner:

sudo apt update
sudo apt install -y curl git jq libicu-dev # `jq` es útil para procesar JSON, `libicu-dev` para Node.js

Crea un directorio para el runner:

mkdir actions-runner && cd actions-runner

Descarga el paquete del runner de GitHub Actions:
Visita la página de lanzamientos de GitHub Actions Runner para encontrar la última versión para Linux x64:
https://github.com/actions/runner/releases
Busca el archivo actions-runner-linux-x64-<version>.tar.gz.

# Ejemplo, reemplaza <version> con la última versión disponible
curl -o actions-runner-linux-x64-<version>.tar.gz -L https://github.com/actions/runner/releases/download/v<version>/actions-runner-linux-x64-<version>.tar.gz
tar xzf ./actions-runner-linux-x64-<version>.tar.gz

Configura el runner:
Necesitarás un token de registro de GitHub.

En GitHub, ve a tu repositorio (o a tu organización si tienes una).

Haz clic en "Settings" (Configuración).

En el menú lateral, ve a "Actions" > "Runners".

Haz clic en "New self-hosted runner".

Selecciona "Linux" y "x64".

Sigue las instrucciones que te da GitHub para los comandos config.sh y run.sh. Te proporcionará un token de registro que solo es válido por un tiempo limitado.

# Ejecuta este comando en tu VM, reemplazando el token y la URL de tu repositorio/organización
./config.sh --url https://github.com/tu_usuario/tu_repo_backend --token <TU_TOKEN_DE_REGISTRO>
# Si es para una organización:
# ./config.sh --url https://github.com/tu_organizacion --token <TU_TOKEN_DE_REGISTRO>

Te preguntará por el nombre del runner (puedes dejar el predeterminado o darle uno como proxmox-backend-runner) y las etiquetas (puedes añadir self-hosted,linux,x64,proxmox-backend o las que quieras, las usaremos en el workflow).

Ejecuta el runner como un servicio (recomendado para que se inicie automáticamente):

sudo ./svc.sh install
sudo ./svc.sh start
# Para verificar el estado:
# sudo ./svc.sh status

Ahora el runner se ejecutará como un servicio de systemd y se iniciará automáticamente al reiniciar la VM.

Crea el archivo .env y service-account-key.json en el directorio de tu aplicación:
Recuerda que estos archivos no están en tu repositorio Git. Necesitas crearlos manualmente en la VM donde se desplegará tu aplicación (el APP_DIR que definiremos en el workflow).

Conéctate a tu VM del backend (donde está el runner) vía SSH.

Navega al directorio donde se desplegará tu aplicación (ej. /home/github-runner/app/admin-backend). Si no existe, créalo.

Crea el archivo .env con las variables de entorno de la base de datos y otras configuraciones.

Crea el archivo service-account-key.json con el contenido JSON de tu clave de cuenta de servicio.

Asegúrate de que los permisos del archivo service-account-key.json sean chmod 600 para que solo el propietario pueda leerlo/escribirlo.

Paso 3: Configurar GitHub Secrets
Para este enfoque, ya no necesitas SSH_PRIVATE_KEY, SSH_HOST, SSH_USERNAME. Solo necesitas los secrets para la base de datos y las credenciales de Google API.

Añade Secrets en GitHub (si no los tienes ya):

Ve a tu repositorio en GitHub.

Haz clic en "Settings" (Configuración).

En el menú lateral, haz clic en "Secrets and variables" > "Actions".

Haz clic en "New repository secret".

Crea los siguientes secrets:

DB_HOST: La IP de tu VM de PostgreSQL.

DB_PORT: El puerto de PostgreSQL (ej. 5432).

DB_USER: El usuario de la base de datos (ej. admin_app_user).

DB_PASSWORD: La contraseña del usuario de la base de datos.

DB_NAME: El nombre de la base de datos (ej. admin_db).

GOOGLE_APPLICATION_CREDENTIALS_JSON: Pega el contenido completo de tu archivo service-account-key.json aquí.

ADMIN_EMAIL: El email del superadministrador para la delegación de dominio.

Paso 4: Crear el Workflow de GitHub Actions (Actualizado)
Este workflow ahora usará el runner autohospedado y ejecutará los comandos directamente en la VM.

Crea la estructura de carpetas:
En la raíz de tu proyecto admin-reset-backend, crea las carpetas .github/workflows/.

mkdir -p .github/workflows

Crea o edita el archivo de workflow:
Dentro de .github/workflows/, crea un archivo llamado deploy.yml.

Pega el siguiente código en deploy.yml:

name: Deploy Node.js Backend with Self-Hosted Runner

on:
  push:
    branches:
      - main # Este workflow se ejecutará cada vez que haya un push a la rama 'main'

jobs:
  deploy:
    runs-on: self-hosted # ¡IMPORTANTE! Usa 'self-hosted' o las etiquetas de tu runner (ej. 'proxmox-backend')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Clona tu repositorio en el runner

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Asegúrate de que coincida con la versión en tu VM

      # Nuevo paso: Configurar npm para instalar paquetes globales en el home del usuario
      # Esto evita problemas de permisos al instalar PM2
      - name: Configure npm global prefix
        run: npm config set prefix '~/.npm-global'

      - name: Install dependencies
        run: npm install # Instala las dependencias en el runner (VM)

      # Nuevo paso: Instalar PM2 globalmente para el usuario del runner
      - name: Install PM2 globally
        run: npm install -g pm2

      # Nuevo paso: Añadir la ruta de PM2 al PATH
      # Ahora npm bin -g apuntará a ~/.npm-global/bin
      - name: Add PM2 to PATH
        run: echo "$(npm bin -g)" >> $GITHUB_PATH

      - name: Create/Update .env and service-account-key.json
        run: |
          # Navegar al directorio de la aplicación (donde se desplegará el código)
          # Asegúrate de que este path sea el mismo donde quieres que esté tu backend en la VM
          # El runner se ejecuta como el usuario 'github-runner' (o el que hayas configurado)
          # Su directorio home es /home/github-runner
          APP_DIR="/home/github-runner/app/admin-backend" 

          mkdir -p $APP_DIR # Asegurarse de que el directorio exista

          # Crear el archivo .env con las variables sensibles
          echo "GOOGLE_APPLICATION_CREDENTIALS=./service-account-key.json" > $APP_DIR/.env
          echo "ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}" >> $APP_DIR/.env
          echo "PORT=3000" >> $APP_DIR/.env
          echo "DB_HOST=${{ secrets.DB_HOST }}" >> $APP_DIR/.env
          echo "DB_PORT=${{ secrets.DB_PORT }}" >> $APP_DIR/.env
          echo "DB_USER=${{ secrets.DB_USER }}" >> $APP_DIR/.env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $APP_DIR/.env
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> $APP_DIR/.env

          # Crear el archivo service-account-key.json con el contenido del secret
          echo '${{ secrets.GOOGLE_APPLICATION_CREDENTIALS_JSON }}' > $APP_DIR/service-account-key.json

          # Asegúrate de que los permisos del archivo de clave sean correctos
          chmod 600 $APP_DIR/service-account-key.json


      - name: Copy code to deployment directory and restart app
        run: |
          # Navegar al directorio de la aplicación (donde se desplegará el código)
          APP_DIR="/home/github-runner/app/admin-backend" 

          # Copiar los archivos del repositorio al directorio de despliegue
          # rsync es más eficiente para copiar solo los cambios
          # El primer './' se refiere a la raíz del repositorio clonado por el runner
          rsync -av --exclude 'node_modules' --exclude '.git' --exclude '.github' ./ $APP_DIR/

          # Navegar al directorio de la aplicación para ejecutar PM2
          cd $APP_DIR

          # Reiniciar la aplicación con PM2
          # Si 'admin-backend' ya está registrado, lo reinicia. Si no, lo inicia.
          pm2 restart admin-backend || pm2 start index.js --name "admin-backend"
          pm2 save # Guarda el estado de PM2 para que se inicie al reiniciar la VM

Paso 5: Probar el Despliegue
Asegúrate de que tu runner autohospedado esté en línea:
En GitHub, ve a tu repositorio (o organización) -> "Settings" -> "Actions" -> "Runners". Deberías ver tu runner con un estado "Idle" (inactivo) o "Online".

Haz un push a tu repositorio:
Guarda el archivo deploy.yml y haz un commit y push a tu rama main:

git add .github/workflows/deploy.yml
git commit -m "Configure self-hosted runner deployment"
git push origin main

Monitorea el workflow en GitHub:

Ve a tu repositorio en GitHub.

Haz clic en la pestaña "Actions".

Deberías ver un workflow llamado "Deploy Node.js Backend with Self-Hosted Runner" ejecutándose.

Haz clic en la ejecución para ver los logs detallados de cada paso.

Si todo está configurado correctamente, el workflow debería completarse con éxito, y tu aplicación Node.js se habrá actualizado y reiniciado en tu VM de Proxmox.

Consideraciones de Seguridad y Mejoras para Runners Autohospedados
Seguridad del Runner: La VM que aloja el runner debe ser tan segura como cualquier servidor de producción. Asegúrate de que esté actualizada, con firewall configurado y solo los puertos necesarios abiertos.

Permisos del Usuario del Runner: El usuario github-runner (o el que uses) en tu VM necesita permisos para:

Acceder y escribir en el directorio de despliegue (/home/github-runner/app/admin-backend).

Ejecutar npm install.

Ejecutar pm2.

Acceder a los archivos .env y service-account-key.json que creas en el paso 4.

Variables de Entorno: El script del workflow crea los archivos .env y service-account-key.json en cada ejecución. Esto es seguro porque los valores provienen de los secrets de GitHub.

rsync: La acción rsync es muy eficiente para copiar solo los archivos modificados, lo que acelera los despliegues.

Manejo de Errores: Añade más manejo de errores y notificaciones al workflow si un paso falla.

Acceso a la VM: Asegúrate de que la VM del runner tenga acceso a la VM de PostgreSQL (misma VLAN, reglas de firewall permitiendo el puerto 5432 entre ellas).

Con esta configuración, has implementado un sistema de CI/CD muy robusto y adecuado para tu entorno.